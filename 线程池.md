

# 线程池

## 一、线程的消耗

为了完成任务，创建很多的线程可以吗？线程真的是越多越好吗？

1. 线程的创建和销毁都是非常重的操作

2. 线程栈本身占用大量内存

3. 线程的上下文切换要占用大量时间

4. 大量线程同时唤醒会使系统经常出现锯齿状负载或者瞬间负载量很大导致宕机

   

## 二、线程池的优势

操作系统上创建线程和销毁线程都是很重的操作，耗时耗性能都比较多，那么在服务执行的过程中，如果业务量比较大，实时的创建线程、执行业务、业务完成后销毁线程，那么会导致系统的实时性能降低，处理业务的能力也会下降。

**知名开源的网络库：**

**C++：muduo， libevent**

**Java**：**Netty， mina**

线程池的优势就是在服务进程启动之初，就事先创建好线程池里的线程，当业务流量到来时需要分配线程，直接从线程池中获取一个空闲线程执行task任务即可，task执行完成后，也不用释放线程，而是把线程归还到线程池中继续给后续的task提供服务。



## 三、线程池分类

### fixed模式线程池

线程池里面的线程个数是固定不变的，一般是ThreadPool创建时根据当前机器的CPU核心数量进行指定。

### cached模式线程池

线程池里面的线程个数是可以动态增长的，根据任务的数量动态的增加线程的数量，但是会设置一个线程数量的阈值，任务处理完毕，如果动态增长的线程空闲了60s没有处理其他任务，那么关闭线程，保持池中最初数量的线程即可。

## 四、线程同步

### 竞态条件（临界区）

代码片段在多线程环境下执行，随着线程的调度顺序不同而导致得到不同的运行结果，那么这段代码是不可重入的。如果在多线程环境下不存在竞态条件，那么这段代码是**可重入的**。



### 线程互斥

#### 互斥锁

std::mutex, std::lock_guard, std::unique_lock等

#### std::atomic原子类型

粒度更低的锁



### 线程通信

#### 条件变量 

std::contidion_variable

#### 信号量

std::semaphore，可以看做成资源计数没有限制的mutex互斥锁。

在C++20 引入了 `std::counting_semaphore` 和 `std::binary_semaphore`（二进制信号量是计数信号量的特例，初始计数为 1），用于线程间的同步和资源管理。

**概念：**

 **• 信号量：**维护一个计数器，线程可以通过 acquire() 减少计数（可能阻塞），通过 release() 增加计数（唤醒等待线程）。

 **• 二进制信号量：**计数器最大值为 1，可替代 std::mutex 用于互斥。 

 **• 计数信号量：**计数器最大值可自定义，用于限制并发访问资源的数量。

**主要接口：**

 • **构造函数**：counting_semaphore(count_type initial_count)，初始计数必须 ≤ 最大计数。

 • **acquire()**：减少计数，若计数为 0 则阻塞，直到有其他线程调用 release()。

 • __try_acquire()__：尝试减少计数，若计数为 0 则立即返回 false。 

 • **try_acquire_for(duration)**：尝试减少计数，超时则返回 false。 

 • **try_acquire_until(time_point)**：同上，基于绝对时间。

 • **release(count = 1)**：增加计数（可指定增加量），唤醒等待线程。



**示例 1：二进制信号量实现互斥锁**

```cpp
#include <semaphore>
#include <thread>
#include <iostream>

std::binary_semaphore sem(1);  // 初始计数为 1，表示资源可用

void worker(int id) {
    sem.acquire();  // 等价于 lock()
    std::cout << "Worker " << id << " acquired the resource.\n";
    // 临界区
    std::this_thread::sleep_for(std::chrono::seconds(1));
    std::cout << "Worker " << id << " released the resource.\n";
    sem.release();  // 等价于 unlock()
}

int main() {
    std::thread t1(worker, 1);
    std::thread t2(worker, 2);
    t1.join();
    t2.join();
    return 0;
}
```



**示例 2：计数信号量限制并发访问**

```cpp
#include <semaphore>
#include <thread>
#include <vector>
#include <iostream>

std::counting_semaphore<3> sem(3);  // 允许最多3个线程同时访问

void task(int id) {
    sem.acquire();
    std::cout << "Task " << id << " is running.\n";
    std::this_thread::sleep_for(std::chrono::seconds(1));
    std::cout << "Task " << id << " completed.\n";
    sem.release();
}

int main() {
    std::vector<std::thread> threads;
    for (int i = 0; i < 5; ++i) {
        threads.emplace_back(task, i);
    }
    for (auto& t : threads) t.join();
    return 0;
}
```



**示例 3：生产者 - 消费者模型**

```cpp
#include <semaphore>
#include <queue>
#include <thread>
#include <iostream>

std::queue<int> tasks;
std::counting_semaphore<10> space_available(10);  // 缓冲区剩余空间
std::counting_semaphore<0> task_available(0);     // 可用任务数
std::mutex mtx;

// 生产者
void producer() {
    for (int i = 0; i < 20; ++i) {
        space_available.acquire();  // 等待空间
        {
            std::lock_guard<std::mutex> lock(mtx);
            tasks.push(i);
            std::cout << "Produced: " << i << std::endl;
        }
        task_available.release();  // 通知有新任务
    }
}

// 消费者
void consumer() {
    for (int i = 0; i < 20; ++i) {
        task_available.acquire();  // 等待任务
        int task;
        {
            std::lock_guard<std::mutex> lock(mtx);
            task = tasks.front();
            tasks.pop();
            std::cout << "Consumed: " << task << std::endl;
        }
        space_available.release();  // 通知有空间
    }
}

int main() {
    std::thread t1(producer);
    std::thread t2(consumer);
    t1.join();
    t2.join();
    return 0;
}
```

